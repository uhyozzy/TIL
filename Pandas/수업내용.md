# 판다스 라이브러리
> import pandas as pd


# 1장. DataFrame생성
## 1. DataFrame 생성 방법

```Python

   DataFrame 생성 방법

   1. dict 이용
     df = pd.DataFrame(dict)

   2. 중첩 리스트 이용
     df = pd.DataFrame(중첩리스트, index=[], columns=[])

   3. np.Series(리스트) 이용
      - df = pd.DataFrame([series, series,....])

      - (하나의) Series는 DataFrame으로 변경 가능
         df = series.to_frame(이름)
```

### 1) dict 이용 
```python
print("1. dict 이용한 DataFrame 생성")
df = pd.DataFrame({"col1" : [4 ,5, 6],
                   "col2" : [7, 8, 9],
                   "col3" : [10, 11, 12]})
print(df)

#
   col1  col2  col3
0     4     7    10
1     5     8    11
2     6     9    12

```

### 2) 중첩 리스트 이용한 DataFrame 생성 => ndarray도 가능
```python
print("1. 중첩 리스트 이용")
df = pd.DataFrame([[4, 7, 10],[5, 8, 11],[6, 9, 12]],
                  index=[1, 2, 3],
                  columns=['col1', 'col2', 'col3'])
print(df)

#
   col1  col2  col3
1     4     7    10
2     5     8    11
3     6     9    12
```

### 3)  Series 사용
```python
print("3. DataFrame 생성")
name =     pd.Series(["유관순","안중근"])
age =      pd.Series([18,31])
birthday = pd.Series(['1920/09/28','1910/03/26'])

hero = pd.DataFrame([name,age,birthday])
hero.columns =["hero1", "hero2"]
hero.index =["이름","나이","생일"]

print(hero)
#
         hero1       hero2
이름         유관순         안중근
나이          18          31
생일  1920/09/28  1910/03/26


print(hero.T)
#
        이름  나이          생일
hero1  유관순  18  1920/09/28
hero2  안중근  31  1910/03/26
```


## 2. DataFrame 변경 

### 1) 컬럼명 변경
```python
df.columns =[값, 값2, ... ]

예시)
df = pd.DataFrame({"col1" : [4 ,5, 6],
                   "col2" : [7, 8, 9],
                   "col3" : [10, 11, 12]})
print(df)
df.columns = ['c1', 'c2', 'c3' ]
print(df)
```

### 2) 인덱스 변경
```python
df.index = [값1, 값2, ... ]

예시)
df = pd.DataFrame({"col1" : [4 ,5, 6],
                   "col2" : [7, 8, 9],
                   "col3" : [10, 11, 12]}, index=['A','B','C'])
print(df)
df.indx = [10, 20, 30]
print(df)
```

## 3. DataFrame 속성 정보 보기

### 1) df.columns 또는 df.keys() : 컬럼정보
```python
df = pd.DataFrame({"col1" : [4 ,5, 6],
                   "col2" : [7, 8, 9],
                   "col3" : [10, 11, 12]})
                   
print(df. columns)
print(df.keys())
```

### 2) df.index : 인덱스 라벨 정보
```python
df = pd.DataFrame({"col1" : [4 ,5, 6],
                   "col2" : [7, 8, 9],
                   "col3" : [10, 11, 12]}, index=['A','B','C'])

print(df.index)
```

### 3) df.values 또는 df.to_numpy(): 값 정보
> 다차원 배열로 반환

```python
print(df.values)
print(df.to_numpy())

```

# 2장 인덱스 관리
## 1. 인덱스 변경 
```python

'''

    인덱스(index) 변경
     - DataFrame의 기존컬럼을 index로 변경
     - inplace=True|False 에 따라서 복사여부 결정
     문법:
           df.set_index(기존컬럼, inplace=True|False)

           df.reset_index( drop=False, inplace=True ) # 기존 index를 컬럼으로 변경하고 새로운 index 생성
           df.reset_index( drop=True, inplace=True ) # 기존 index를 삭제하고 새로운 index 생성
'''

df = pd.DataFrame({    "date":['2021','2022'],
                       "City": ["Seoul", "Seoul"],
                       "Temperature": [32, 34]
                       })
print("1. 원본 DataFrame")
print(df)
#
   date   City  Temperature
0  2021  Seoul           32
1  2022  Seoul           34

```

### 1) 기존 컬럼을 인덱스로 변경
```python

df.set_index('date', inplace=True)
print(df)

#
       City  Temperature
date                    
2021  Seoul           32
2022  Seoul           34
```

### 2) 새로운 인덱스로 변경
```python

df.set_index(기존컬럼, inplace = True | False)
drop = T : 기존 인덱스를 삭제하고 새로운 인덱스 생성 
drop = F : 기존 인덱스를 컬럼으로 변경하고 새로운 인덱스 생성
(drop과 inplace의 파라미터 위치는 상관 없음)

df.reset_index(drop=False, inplace=True)         # 기존 인덱스를 컬럼으로 변경하고 새로운 인덱스 생성
print(df)
#
   index  date   City  Temperature
0      0  2021  Seoul           32
1      1  2022  Seoul           34


df.reset_index(drop=True, inplace=True)            # 기존 인덱스를 삭제하고 새로운 인덱스 생성
print(df)
#
   date   City  Temperature
0  2021  Seoul           32
1  2022  Seoul           34


```

### 3) index 재배치
```python
(1) df.reindex(index=값) : 기존 인덱스 재배치

df = pd.DataFrame({ "date":['2021','2022','2012','2023','2024'],
                    "City": ["Seoul", "Seoul", "Seoul","Seoul","Seoul"],
                    "Temperature": [32, 34,32, 34,53]
                  },index=list('AECBD'))
print(df)
#
   date   City  Temperature
A  2021  Seoul           32
E  2022  Seoul           34
C  2012  Seoul           32
B  2023  Seoul           34
D  2024  Seoul           53


new_df = df.reindex(index=list("ABCDE")) #inplace 없어서 복사본을 만들어줘야 함 
print(new_df)
#
   date   City  Temperature
A  2021  Seoul           32
B  2023  Seoul           34
C  2012  Seoul           32
D  2024  Seoul           53
E  2022  Seoul           34

```


### 4) df병합시 기존 index값이 중복발생 ==> ignore_index=True 로 index값을 재설정
> df와 df2 연결시 인덱스도 연결되서 중복됨.
> index로 색인해야 하기 때문에 중복되면 안되기 때문에 ignore_index로 중복문제를 해결해야 함 
> 자동으로 인덱스 생성

```python
df1 = pd.DataFrame({'a':[12,2]},
                   index=[1,2])
df2 = pd.DataFrame({'a':[120,20]},
                   index=[1,2])

new_df = pd.concat([df1, df2])
print(new_df)
# 인덱스가 중복됨 
     a
1   12
2    2
1  120
2   20

new_df = pd.concat([df1, df2], ignore_index=True)
print(new_df)
# 인덱스 중복현상 해결
     a
0   12
1    2
2  120
3   20

```
# 3장. 조회(색인)


```
 행과 컬럼은 label과 Integer location으로 참조할 수 있다.
   다음과 같은 3가지 방법으로 참조한다.
   
   가.  [] : 인덱싱 연산자, 컬럼(들)을 선택하는 목적
           예> [컬럼] ==> Series 반환 ( index와 값 으로 구성됨 )
              [[컬럼,컬럼]] ==> DataFrame 반환
              
   나.  .loc :  label만을 사용한다. ( 기본적으로 index의 label로 인식 )
               label은 single, list, slice 형태 모두 가능하다.
               행과 열을 동시에 조회할 수 있다. df.loc[행,열]
               행과 컬럼 모두 label 만 사용 가능하다.
               
   다.  .iloc :   loc와 유사하지만 정수위치값만을 사용한다.
                  행과 컬럼 모두 위치값 만 사용 가능하다.
```


## 1. 컬럼 조회
```python
    DataFrame 의 컬럼(들) 조회 ==> SQL의  projection 기능

* 컬럼 선택 
   가.  [] : 인덱싱 연산자, 컬럼(들)을 선택하는 목적
      예> [컬럼] ==> Series 반환 ( index와 값 으로 구성됨 )
          [[컬럼,컬럼]] ==> DataFrame 반환

    1. 단일컬럼 조회 ==> Series 반환
      1) df.컬럼명
      2) df['컬럼명']

    2. 멀티컬럼 조회 ==> DataFrame 반환
      1) df[['컬럼명','컬럼명2',...]]
```

### 1) 싱글 및 멀티 컬럼 조회
```python
df = pd.DataFrame({"col1" : [4 ,5, 6, 6],
                   "col2" : [7, 8, 9, 9],
                   "col3" : [10, 11, 12, 12]},
                   index = list("ABCD"))

print("1. col1 컬럼만 조회")
print(df.col1 )     # 도트 이용, Series 반환
#
A    4
B    5
C    6
D    6
Name: col1, dtype: int64


print("2. col1 컬럼만 조회")
print(df['col1'])  # 대괄호 이용, Series 반환
#
A    4
B    5
C    6
D    6
Name: col1, dtype: int64


print("3. col1와 col2 컬럼 조회")
print(df[['col2', 'col1']])  # fancy 색인 비슷 , # DataFrame 반환
#
   col2  col1
A     7     4
B     8     5
C     9     6
D     9     6


print("4. col1 컬럼만 여러번 조회")
print(df[['col1','col1','col1']])  # DataFrame 반환
#
   col1  col1  col1
A     4     4     4
B     5     5     5
C     6     6     6
D     6     6     6
```


### 2) 행 조회
```python
   DataFrame 의 행(들) 조회 ==> SQL의  selection 기능

    1. 행 인덱스의 label 이용 
      - df.loc[label]                ==> 인덱싱 label, Series 반환
      - df.loc[[label,label2,....]]  ==> fancy label, DataFrame 반환
      - df.loc[lable:label2]          ==> slicing label, DataFrame 반환  
      - df.[[True,False,..]]      ==> boolean 색인 
      - 기본 문법 : df.loc[행label, 컬럼label]
      - 행lable은 인덱스라벨, fancy, 슬라이싱, boolean 모두 가능
      - 컬럼 lable은 인덱스라벨, fancy, 슬라이싱, boolean 모두 가능
      
      
    2. 행 인덱스의 위치 이용
      - df.iloc[위치]                  ==> 인덱싱 위치, Series 반환
      - df.iloc[[위치,위치1,...]]       ==> fancy 위치, DataFrame 반환
      - df.iloc[위치:위치2]             ==> slicing 위치, DataFrame 반환
      - df.iloc[[True,False,..]]      ==> boolean 색인 
      - 기본문법 : df.iloc[행위치, 컬럼위치]


df = pd.DataFrame({"col1" : [4 ,5, 6, 6,1],
                   "col2" : [7, 8, 9, 9,2],
                   "col3" : [10, 11, 12, 12,10]},
                   index = list("ABCDE"))
print(df)
#
   col1  col2  col3
A     4     7    10
B     5     8    11
C     6     9    12
D     6     9    12
E     1     2    10 


(1) df.loc 
(1-1) A 행 출력(인덱싱 label)
print(df.loc["A"]) # Series 반환
#
col1     4
col2     7
col3    10
Name: A, dtype: int64


(1-2) A 와 B행 출력(fancy label)
print(df.loc[["A","B"]]) # DataFrame 반환 (하나의 행은 series 여러개는 dataframe)
#
  col1  col2  col3
A     4     7    10
B     5     8    11


(1-3) B행부터 D행까지 출력(slicing label)
print(df.loc["B":"D"]) # DataFrame 반환
#
   col1  col2  col3
B     5     8    11
C     6     9    12
D     6     9    12


(1-4) 4. A,C,E행 출력(boolean label)
print(df.loc[[True,False,True,False,True]]) # DataFrame 반환
#
   col1  col2  col3
A     4     7    10
C     6     9    12
E     1     2    10


(2) df.iloc 
예시)
#
       col1  col2  col3
1 A     4     7    10
2 B     5     8    11
3 C     6     9    12
4 D     6     9    12
5 E     1     2    10 

(2-1)  A 행 출력(인덱싱 위치)
print(df.iloc[0]) # Series 반환
#
col1     4
col2     7
col3    10
Name: A, dtype: int64


(2-2) A 와 B행 출력(fancy 위치)
print(df.iloc[[0,1]]) # DataFrame 반환
#
   col1  col2  col3
A     4     7    10
B     5     8    11


(2-3)  B행부터 D행까지 출력(slicing label)
print(df.iloc[1:-1]) # DataFrame 반환
#
   col1  col2  col3
B     5     8    11
C     6     9    12
D     6     9    12

(2-4)   4. A,C,E행 출력(boolean label)
print(df.iloc[[True,False,True,False,True]]) # DataFrame 반환
#
   col1  col2  col3
A     4     7    10
C     6     9    12
E     1     2    10


### 3) 조회후 값 변경
```python
df = pd.DataFrame({"col1" : [4 ,5, 6, 6,1],
                   "col2" : [7, 8, 9, 9,2],
                   "col3" : [10, 11, 12, 12,10]},
                   index = list("ABCDE"))
print(df)
#
   col1  col2  col3
A     4     7    10
B     5     8    11
C     6     9    12
D     6     9    12
E     1     2    10


3-1) A행의 모든 값 변경 (인덱싱)
df.loc['A']=100
print(df)
#
   col1  col2  col3
A   100   100   100
B     5     8    11
C     6     9    12
D     6     9    12
E     1     2    10


3-2) B, C행의 모든 값 변경 (fancy)
df.loc[['B','C']] = 200
print(df)
#
   col1  col2  col3
A   100   100   100
B   200   200   200
C   200   200   200
D     6     9    12
E     1     2    10

3-3) D행의 col2 값을 900으로 변경
df.loc['D', 'col2'] =900
print(df)
#
   col1  col2  col3
A   100   100   100
B   200   200   200
C   200   200   200
D     6   900    12
E     1     2    10

```

# 4장. 컬럼 추가 및 삽입
```
   DataFrame에 컬럼 추가 
      - 기존 컬럼에 값을 갖고 추가정보를 얻을 때 

  1.  df['컬럼명'] = 리스트
      df['컬럼명'] = Series

  2. new_df = df.assign(컬럼명=리스트) 

  3. new_df = df.assign(컬럼명=함수, 컬럼명=함수)

  4.  new_df = pd.concat([df,df2], axis=1)
  
  DataFrame에 컬럼 삽입
  
   1. df.insert(idx, 컬럼명, 값 )

```

# 1.  df['컬럼명'] = 리스트 or Series
```python
df = pd.DataFrame({"이름":['홍길동','이순신','유관순','강감찬'],
                   "국어":[30, 26, 11, 10],
                   "수학":[20, 12, 20, 12]
                 }, index=[1,2,3,4])
print(df)
#                
    이름  국어  수학
1  홍길동  30  20
2  이순신  26  12
3  유관순  11  20
4  강감찬  10  12



문법1 ) df['컬럼명'] = 리스트
df['영어'] = [10, 20, 30, 40]
print(df)
#
    이름  국어  수학  영어
1  홍길동  30  20  10
2  이순신  26  12  20
3  유관순  11  20  30
4  강감찬  10  12  40

문법2 ) df['컬럼명'] = Series         
      - 시리즈의 경우 0부터 인덱스를 줌, 
      - 원래의 dataframe은 인덱스 1부터 시작하기 때문에 dataframe에서 index를 지정하지 않으면 0부터 시작함 
df['과학'] = pd.Series(data= [10, 20, 30, 40], index=[1, 2, 3, 4])
print(df)
#
    이름  국어  수학  영어  과학
1  홍길동  30  20  10  10
2  이순신  26  12  20  20
3  유관순  11  20  30  30
4  강감찬  10  12  40  40



+) 총합 컬럼 추가하기
df["총합"] = df['국어'] + df['수학'] + df['영어'] + df['과학']
#
    이름  국어  수학  영어  과학   총합
1  홍길동  30  20  10  10   70
2  이순신  26  12  20  20   78
3  유관순  11  20  30  30   91
4  강감찬  10  12  40  40  102


+) 평균 컬럼 추가하기 
df["평균"] = np.round(df["총합"]/4,1)
#
    이름  국어  수학  영어  과학   총합    평균
1  홍길동  30  20  10  10   70  17.5
2  이순신  26  12  20  20   78  19.5
3  유관순  11  20  30  30   91  22.8
4  강감찬  10  12  40  40  102  25.5


+) 평균 관련 : series에 데이터 타입을 변경하는 함수
df["평균"] = df["평균"].astype(np.int32)
print(df)

+) 합격 여부 (평균이 20보다 크면 '합격', 20보다 작으면 '불합격' 출력)
df["합격여부"] = [ "합격"  if n > 20  "불합격 for n in df["평균"]] #---> 3항 연산자
print(df)
   
```

# 2. assign 함수
```python
예시)
df = pd.DataFrame({"이름":['홍길동','이순신','유관순','강감찬'],
                   "국어":[30, 26, 11, 10],
                   "수학":[20, 12, 20, 12]
                 }, index=[1,2,3,4])
                 
                 
1) new_df =df.assign (컬럼명=리스트)                 
df = df.assign(영어=[30,42,53,21]) # 따옴표 없음 주의! 

2) new_df = df.assign (컬럼명=함수, 컬럼명=함수)
#def total(x) :
#    return x["국어"] + x["수학"] + x["영어"]
    
#total = lambda x: x["국어"] + x["수학"] + x["영어"]
# df = df.assign(총합=total)
df = df.assign(총합=lambda df: df["국어"]+df["수학"]+df["영어"]
               총합2=lambda df: df["국어"]+df["수학"]+df["영어"]) #한번에 여러개 만들 수 있음

print(df)

# 평균 컬럼 추가하기
df = df.assign(평균=lambda x: np.round(x['총합']/3,1))
print(df)


```

# 4. insert함수

```python

- 문법 : df.insert(idx, 컬럼명, 값 )

df = pd.DataFrame({"이름":['홍길동','이순신','유관순','강감찬'],
                   "국어":[30, 26, 11, 10],
                   "수학":[20, 12, 20, 12]
                 }, index=[1,2,3,4])

df.insert(1,"영어", [30, 26, 11, 10])
print(df)
```

# 5장. 컬럼삭제 
```python
    컬럼삭제

    1. 단일컬럼 삭제
       df.pop('컬럼명')
       del df['컬럼명']

    2. 다중 컬럼 삭제
       df.drop(columns=리스트)
       df.drop(리스트, axis=1)

df = pd.DataFrame({"이름":['홍길동','이순신','유관순','강감찬'],
                   "국어":[30, 26, 11, 10],
                   "수학":[20, 12, 20, 12],
                   "영어":[30, 26, 11, 10],
                   "과학":[20, 12, 20, 12],
                   "체육":[30, 26, 11, 10],
                   "보건":[20, 12, 20, 12],
                   "화학":[30, 26, 11, 10],
                   "수리":[20, 12, 20, 12]
                 }, index=[1,2,3,4])
```
## 1. 단일 컬럼 삭제
```python
df.pop("국어")
del df["수학"]
```

## 2. 다중 컬럼 삭제
```python
df.drop(columns=["영어","과학"], inplace=True)
df.drop(["체육","보건"], inplace=True, axis=1)
print(df)
```

# 6장. 행 추가 및 삭제

```
   DataFrame 행(row) 추가

  1. 한번에 하나씩 추가 ==> 버전업 1.3.0 이후에는 지원 안됨.
    # new_df = df.append(df2, ignore_index=True)

  2. 한번에 여러개 추가
    new_df = pd.concat([df,df2,..], axis=0 , ignore_index=True)
    
```

## 1. 행추가
```python
(1) 한번에 하나씩 추가

info={"Name":["유관순","안중근"],"age":[18,31],"birthday":['1920/09/28','1910/03/26']}
df = pd.DataFrame(info)

info2 = {"Name":["홍길동","강감찬"],"age":[22,43],"birthday":['1990/09/28','1980/03/26']}
df2 = pd.DataFrame(info2)

print(df)

  Name  age    birthday
0  유관순   18  1920/09/28
1  안중근   31  1910/03/26

print(df2)

  Name  age    birthday
0  홍길동   22  1990/09/28
1  강감찬   43  1980/03/26


new_df = pd.concat([df, df2], axis=0, ignore_index=True)

(2) 한꺼번에 여러개 지정 가능
new_df = pd.concat([df, df2, df2, df2], axis=0, ignore_index=True)
print(new_df)
```

## 2. 행삭제 
```python

   DataFrame 행(row) 삭제

   1. new_df = df.drop(index=[인덱스명(라벨), 인덱스명(라벨)])

   2. new_df = df.drop([인덱스명, 인덱스명], axis=0)
    

df = pd.DataFrame({"이름":['홍길동','이순신','유관순','강감찬'],
                   "국어":[30, 26, 11, 10],
                   "수학":[20, 12, 20, 12]
                 }, index=[1,2,3,4])

    이름  국어  수학
0 1  홍길동  30  20
1 2  이순신  26  12
2 3  유관순  11  20
3 4  강감찬  10  12

df.drop(index=[1, 2], inplace=True)
df.drop([3], inplace=True, axis=0)
print(df)
```

# 7장. Null값 조회 및 변경
## 1. 널(null) 값 조회
```python
<< 요약 >>

     널(null) 값 : None, NaN or NA as null

    가.  Pandas 함수 이용
     1)  bool = pd.isna(스칼라|Series|df)
     2)  bool = pd.isnull(스칼라|Series|df)
     3)  bool = pd.notnull(스칼라|Series|df)

    나.  DataFrame 함수 이용
     1)  bool = df.isnull()
         bool = df[컬럼명].isnull()
         bool = df[[컬럼,컬럼2]].isnull()
```

```python
df = pd.DataFrame({ "col1" : [1 ,1, 1, np.nan, 1],
                    "col2" : [2, 2, 2, 2, np.nan],
                    "col3" : [ np.nan, 3, 3, 3, 3],
                    "col4" : [ np.nan, np.nan, np.nan, np.nan, np.nan]},
                    index = [1, 2, 3, 4, 5])

#
   col1  col2  col3  col4
1   1.0   2.0   NaN   NaN
2   1.0   2.0   3.0   NaN
3   1.0   2.0   3.0   NaN
4   NaN   2.0   3.0   NaN
5   1.0   NaN   3.0   NaN

가. pandas함수 이용
1) 전체 대상(df)으로 null값 찾기 
print(pd.isna(df))
print(pd.isnull(df))

print(pd.notnull(df))
print(~pd.isnull(df))

2) 특정 컬럼(series)에서 null값 찾기  #----컬럼이 하나면 series, 두개 이상이면 dataframe
print(pd.isna(df['col1']))
print(pd.isnull(df['col1']))

3) 특정 컬럼들(DataFrame)에서 null값 찾기
print(pd.isna(df[['col1','col2']]))
print(pd.isnull(df[['col1','col2']]))

나. DataFrame 함수 이용
1) 전체 대상(df)으로 null값 찾기
print(df.isnull())
print(df.isna())

2) 특정 컬럼(series)에서 null값 찾기
print(df['co1'].isnull())

3) 특정 컬럼들(DataFrame)에서 null값 찾기
print(df[['co1','col2']].isnull())
```
                  
                    
## 2. 널(null) 값 삭제                   
```python
<< 요약 >>
     null 값 삭제

     가. 행(axis=0) 삭제
        new_df = df.dropna(axis=0|'index', inplace=False)
        new_df = df.dropna(axis=0|'index', how="any|all" , inplace=False))


     나. 열(axis=1) 삭제
        new_df = df.dropna(axis=1|'column', inplace=False)
        new_df = df.dropna(axis=1|'column', how="any|all" , inplace=False))
```
```python

df = pd.DataFrame({ "col1" : [1 ,1, 1, 1, 1],
                    "col2" : [2, 2, 2, 2, np.nan],
                    "col3" : [3, np.nan, np.nan, np.nan, np.nan],
                    "col4" : [ 2, np.nan, np.nan, np.nan, np.nan]},
                    index = [1, 2, 3, 4, 5])             
                    
#    col1  col2  col3  col4
1     1   2.0   3.0   2.0
2     1   2.0   NaN   NaN
3     1   2.0   NaN   NaN
4     1   2.0   NaN   NaN
5     1   NaN   NaN   NaN


가. 행삭제
new_df = df.dropna(axis=0)
print(new_df)

new_df = df.dropna(axis=0, how="all") 
# --->how="all"은 전체 행이 null일때만 실행됨(하나라도 null아니면 실행안됨)
print(new_df)


나. 열삭제 
new_df = df.dropna(axis=1) #하나라도 null값이면 실행 됨 
print(new_df)

new_df = df.dropna(axis=1, how="all") 
print(new_df)

```                    

## 3. 널(null) 값 변경     
```
     null 값 변경
      - 임의의 값으로 변경 null -> 1
      - NaN 앞이나 뒤에 위치한 값으로 변경 (근처에 있는 값으로 변경)
      - df.fillna(value, method='bfill|ffill|None', inplace=False, limit=n )
      - value : 치환될 임의의 값
      - bfill : 뒤에 있는 값, ffill : 앞에 있는 값 

```
```python

df = pd.DataFrame({ "col1" : [1 ,1, 1, 1, np.nan],
                    "col2" : [2, 2, 2, 2, np.nan],
                    "col3" : [3, 3, 3, 3, np.nan],
                    "col4" : [ np.nan, np.nan, np.nan, np.nan, np.nan]},
                    index = [1, 2, 3, 4, 5])
#
   col1  col2  col3  col4
1   1.0   2.0   3.0   NaN
2   1.0   2.0   3.0   NaN
3   1.0   2.0   3.0   NaN
4   1.0   2.0   3.0   NaN
5   NaN   NaN   NaN   NaN

1) 전체 DataFrame에 있는 null 값을 임의의 값으로 변경
new_df = df.fillna(0) # 임의의 값=0
print(new_df)

2) 컬럼마다 다르게 null 값을 임의의 값으로 변경
new_df = df.fillna({"col1":-1, "col2":-2}) # col1 =-1, col2 =-2
print(new_df)

3) null의 주위에 있는 값 으로 변경
- 예시 변경
df = pd.DataFrame({ "col1" : [1 ,np.nan, 3, 4, np.nan],
                    "col2" : [1 ,np.nan, 3, 4, np.nan],
                    "col3" : [1 ,2, np.nan, 4, np.nan]},
                    index = [1, 2, 3, 4, 5])     
#                    
   col1  col2  col3
1   1.0   1.0   1.0
2   NaN   NaN   2.0
3   3.0   3.0   NaN
4   4.0   4.0   4.0
5   NaN   NaN   NaN

3-1) null의 앞에 있는 값(forward)으로 변경
new_df = df.fillna(method='ffill')
print(new_df)

#
   col1  col2  col3
1   1.0   1.0   1.0
2   1.0   1.0   2.0
3   3.0   3.0   2.0
4   4.0   4.0   4.0
5   4.0   4.0   4.0

3-2) null의 뒤에 있는 값(back)으로 변경
new_df = df.fillna(method='bfill')
print(new_df)
#
   col1  col2  col3
1   1.0   1.0   1.0
2   3.0   3.0   2.0
3   3.0   3.0   4.0
4   4.0   4.0   4.0
5   NaN   NaN   NaN  # -->더 뒤에있는 값이 없으면 그대로

```

# 8장. 정렬
## 1. 정렬
```python
<< 요약 >>

   DataFrame 정렬

   1) 값으로 정렬하는 방법 
      df.sort_values(by=컬럼명, ascending=True, inplace=False, ignore_index=False, kind="quicksort", na_position="last")
      - kind 정렬 알고리즘 기본이 quicksort
      - na_position="last" : NaN값이 가장 마지막에 옴 (first로 설정하면 가장 첫번째로 옴)
      - ascending = True : 오름차순 , = False : 내림차순

   2) 행 라벨 및 컬럼 라벨 이름순으로 정렬
      new_df = df.sort_index(axis=0|1)

```
```python
import pandas as pd
import numpy as np
import seaborn as sns

df = sns.load_dataset("mpg") #----> 많은 value값을 가진 DataFrame 만들기 
df = df.head(10) # 상위 10개만 뽑아옴 혹은 df = df.tail(10) # 하위 10개만 뽑아옴
df.index=list('HDAFCBEGIJ') # 인덱스 설정
df[df['name']=='ford torino']=np.nan
print(df, df.shape)

1) mpg 컬럼 오름차순 정렬 
new_df = df.sort_values(by="mpg", ascending=True, inplace=False, na_position="last")
print(new_df)

2) 다중정렬/ mpg, displacement 컬럼 오름차순 정렬 
new_df = df.sort_values(by=["mpg","displacement"], ascending=False, inplace=False, na_position="last")
print(new_df)

3) 행단위(행 라벨) 정렬
- 오름차순
new_df = df.sort_index(axis=0)      #axis=0 생략가능 
print(new_df)
- 내림차순
new_df = df.sort_index(axis=0, ascending=False)
print(new_df)

4) 열단위(컬럼명) 정렬
- 오름차순 
new_df = df.sort_index(axis=1)      #axis=1 설정시 생략 불가
print(new_df)
- 내림차순
new_df = df.sort_index(axis=0, ascending=False)
print(new_df)

```

# 9장. 함수 
## 1. DataFrame의 기술통계관련 함수
```python
  1) 최대(소)값         ==>  df.max(), df.min()
     누적최대(소)값,     ==>  df.cummax(), df.cummin()
      최대(소)값label   ==>  df.idxmax(), df.idxmin()
  2) (누적)합계         ==>  df.sum(), df.cumsum()
      평균              ==>  df.mean()
      중앙값            ==>  df.median()
      (누적)곱          ==>  df.prod(), df.cumprod()
  3) 사분위             ==>  df.quantile()
     분산               ==>  df.var()
      표준편차           ==>  df.std()
  4) count(갯수)         ==>  df.count()
  5) 통합 통계           ==>  df.describe() : 통계정보를 한번에 볼 수 있음

```
```python
import  pandas as pd
import numpy as np

df = pd.DataFrame({"col1" : [4 ,6, 9, 5, 15],
                   "col2" : [16, 8, np.nan, 6, 6],
                   "col3" : [10, 11, 12, 12, 12]},
                    index = list("ABCDE"))
print(df)
#
   col1  col2  col3
A     4  16.0    10
B     6   8.0    11
C     9   NaN    12
D     5   6.0    12
E    15   6.0    12

1) 최대/최소 찾기
■ 행/컬럼 을 축으로 최대값 구하기
df.max(axis=0) #axis=0 위/아래 , axis=1 왼쪽/오른쪽
df.min(axis=0)

df.max(axis=1)
df.min(axis=1)

■ 행/컬럼을 축으로 누적해서 비교했을 때 최대/최소
x = df.cummax(axis=0)
x = df.cummin(axis=0)

x = df.cummax(axis=1)
x = df.cummin(axis=1)

■ 최대/최소값을 가진 컬럼/인덱스 라벨 구하기 
x = df.idxmax(axis=0)
x = df.idxmin(axis=0)

2) 합 / 평균 / 중앙값 / 곱 구하기
■ 행or컬럼을 축으로 총합/누적총합 구하기
x = df.sum(axis=0)
x = df.cumsum(axis=0)

x = df.sum(axis=1)
x = df.cumsum(axis=1)

■ 행/컬럼을 축으로 평균 구하기
x = df.mean(axis=0)
x = df.mean(axis=1)

■ 행/컬럼을 축으로 중앙값 구하기
x = df.median(axis=0)
x = df.median(axis=1)

■ 행/컬럼을 축으로 곱연산 구하기
x = df.prod(axis=0)
x = df.prod(axis=1)

3) 분산 / 표준편차 / 갯수 구하기 
■ 행/컬럼을 축으로 분산 구하기
x = df.var(axis=0)
x = df.var(axis=1)

■ 행/컬럼을 축으로 표준편차 구하기
x = df.std(axxis=0)
x = df.std(axxis=1)

■ 갯수구하기 : count는 null 제외
x = df.count(axis=0)

4) 통합 통계 데이터
- 평균, 표준편차, 분산 등의 다양한 정보를 한번에  제공 
x = df.describe()
x = df.info()
print(df.head()) # 상위 5개 값 출력 
```

## 2. DataFrame의 기본 함수
```python
   1) 값 변경                                  ==>  df.replace()
   2) 컬럼명 및 인덱스명 변경                     ==> df.rename(columns|index)
   3) 모든(특정) 컬럼(행)값의 참/거짓 여부          ==>  df.any() , df.all()
   4) 중복조회 및 제거                           ==>  df.duplicated(),  df.drop_duplicates()

   5) 임의의 함수 적용 ==> df.apply(함수, axis=0|1)
      임의의 함수를 한번에 DataFrame의 행과 열에 적용.

   6) 문자열 이용한 연산  === > df.eval('expr:str', inplace=False)

   7) 값이 있으면 True, 아니면 False ==> df.isin(집합형)
    
   8) unique한 값의 갯수 ==> df.nunique(dropna=True) 
                            dropna=False 면 nan 포함해서 갯수 반환
```
### 1) df.replace()
```python

df = pd.DataFrame({ "a" : [0 ,10, 100],
                    "b" : [2, 20, 200],
                    "c" : [3, 20, 300]},
                    index = list('ABC'))
#
     a    b    c
A    0    2    3
B   10   20   30
C  100  200  300


■  df.replace(dict, new값) : 값 변경
- dict에 지정된 값을 new값으로 치환
new_df = df.replace({'a':100}, 999) # a컬럼의 100 이라는 값을 999으로 변경 
new_df = df.replace({'a':100, 'b':[2,200]}, 999) #a컬럼의 100값과, b컬럼의 2, 200값을 변경

■ df.replace({old:new, old:new}) : old값을 new 값으로 변경 
new_df = df.replace({20:2000, 3:3000})
print(new_df)

```
### 2) 컬럼명 및 인덱스명 변경
```python
■ 컬럼명 변경
new_df = df.rename(columns={'a':'co11','b':'co12'})

■ 인덱스명 변경
new_df = df.rename(columns={'A':'row1','B':'row2'})
```

### 3) 모든(특정) 컬럼(행)의 참/거짓 여부 
```python
x = df.all(axis=0) #모든 컬럼이 참인가? 0이면 False 0이 아니면True
x = df.all(axis=1) #모든 행값이 참인가?

x = df.any(axis=0) #어떤 컬럼이 참인가?
x = df.any(axis=1) #어떤 행값이 참인가?

```

### 4) 중복 조회 및 제거 
```python

df = pd.DataFrame({"k1":['one']*3 + ['two']*4,
                  "k2":[1,1,2,3,3,4,4] })
print(df)

#    k1  k2
0  one   1
1  one   1
2  one   2
3  two   3
4  two   3
5  two   4
6  two   4 

■ 행단위로 중복 체크
x = df.duplicated()
print(x)

■ 중복된 값을 제거 하고 출력
new_df = df.drop_duplicates()
print(new_df)

```

### 5) 임의의 함수 적용 ==>callback처리(함수명 반환)
```python
df = pd.DataFrame({"국어":[50,60,70,80,90],"수학":[100,100,100,100,100]})
print(df)
#   국어   수학
0  50  100
1  60  100
2  70  100
3  80  100
4  90  100

x=df.apply(np.sum, axis=0) #--> 평균을 구할 땐 np.mean도 가능 
print(x)
# 
국어    350
수학    500
dtype: int64

x=df.apply(sum, axis=1) #--> sum을 써도 가능 
print(x)
#
0    150
1    160
2    170
3    180
4    190
dtype: int64

```

### 6) df.isin(집합형) 
> 중요, SQL의 in연산자와 비슷 
```python
new_df = df.isin([60, 80]) #찾고자 하는 값을 괄호 안에 넣어줌
new_df = df.isin("국어":[60, 80]) #특정 컬럼에서만 확인 나머지 컬럼에서는 값이 있어도 False로 출력
print(new_df)
```

### 7) unique한 값(종류)의 갯수
> unique = null이 아닌 값 

> df.unique(dropna=True)가 기본값으로 기본적으로 null 제외 

> dropna=False면 nan 포함해서 갯수 반환

> nuique와 uniue차이 : df.nunique(갯수 반환), series.unique(값 반환)

```python
df = pd.DataFrame({ "col1" : [1 ,2, 2, None, 1],
                    "col2" : [2, 3, 2, 2, np.nan],
                    "col3" : [ np.nan, 3, 2, 3, 3],
                    "col4" : [ np.nan, np.nan, np.nan, np.nan, np.nan]},
                    index = [1, 2, 3, 4, 5])
print(df)
#   col1  col2  col3  col4
1   1.0   2.0   NaN   NaN
2   2.0   3.0   3.0   NaN
3   2.0   2.0   2.0   NaN
4   NaN   2.0   3.0   NaN
5   1.0   NaN   3.0   NaN

■ null값 제외
x = df.nuique(axis=0)
x = df.nuique(axis=1)
print(x)

■ null 값 포함
x = df.nunique(axis=0, dropna=False)

```


## 3. Series의 기술통계관련 함수
```python

  1. 최대(소)값         ==>  df[[컬럼,컬럼2]].max(), df[[컬럼,컬럼2]].min()
     누적최대(소)값,     ==>  df[[컬럼,컬럼2]].cummax(), df[[컬럼,컬럼2]].cummin()
      최대(소)값label  ==>  df[[컬럼,컬럼2]].idxmax(), df[[컬럼,컬럼2]].idxmin()
  2. (누적)합계         ==>  df[[컬럼,컬럼2]].sum(), df[[컬럼,컬럼2]].cumsum()
      평균             ==>  df[[컬럼,컬럼2]].mean()
      중앙값            ==>  df[[컬럼,컬럼2]].median()
      (누적)곱          ==>  df[[컬럼,컬럼2]].prod(), df[[컬럼,컬럼2]].cumprod()
  3. 사분위             ==>  df[[컬럼,컬럼2]].quantile()
     분산               ==>  df[[컬럼,컬럼2]].var()
      표준편차           ==>  df[[컬럼,컬럼2]].std()
  4. count(갯수)         ==>  df[[컬럼,컬럼2]].count()
  5. 통합 통계           ==>  df[[컬럼,컬럼2]].describe()

```
```python
df = pd.DataFrame({"col1" : [4 ,6, 9, 5, 15],
                   "col2" : [16, 8, np.nan, 6, 6],
                   "col3" : [10, 11, 12, 12, 12]},
                    index = list("ABCDE"))
print(df)

1) 최대 최소
■ 행을 축으로 최대/최소값 구하기
x = df['col1'].max(axis=0) 
x = df['col1'].min(axis=0) 

■ 행을 축으로 누적최대 /누적 최소 구하기
x = df['col1'].cummax(axis=0) 
x = df['col1'].cummin(axis=0) 

■ 행을 축으로 총합/누적총합 구하기 
x = df['col1'].sum(axis=0) 
x = df['col1'].cumsum(axis=0) 

■ 행을 축으로 평균 구하기
x = df['col1'].mean(axis=0)

■ 행을 축으로 중앙값 구하기
x = df['col1'].median(axis=0)

■ 행을 축으로 곱 연산 구하기
x = df['col1'].prod(axis=0)

■ 행을 축으로 분산 구하기
x = df['col1'].var(axis=0)

■ 행을 축으로 표준편차 구하기
x = df['col1'].std(axis=0)

■ 행을 축으로 갯수 구하기
x = df['col1'].count(axis=0)

```
## 4. Series기본 함수
```python
   1. 값 변경                                  ==>  df[컬럼].replace()
   2. 컬럼명 및 인덱스명 변경                     ==> dfdf[컬럼].rename()
   3. 모든(특정) 컬럼(행)값의 참/거짓 여부          ==>  df[컬럼].any() , df[컬럼].all()
   4. 중복조회 및 제거                           ==>  df[컬럼].duplicated(),  df[컬럼].drop_duplicates()
   
   5. 임의의 함수 적용 ==> df[컬럼].apply(함수)
 
   6. 범위에 포함되면 True, 아니면 False ==> df[컬럼].between(start, end)
   7. 값이 있으면 True, 아니면 False ==> df[컬럼].isin(집합형)


   8. unique한 값 리스트 반환 :  df[컬럼].unique()
      NaN 제외한 unique한 값 갯수 반환 :  df[컬럼].nunique(dropna=True)
      

   9.  NaN 제외한 값 빈도수 반환 :  df[컬럼].value_counts()
   
   10. df["컬럼명"].str.문자열함수 
     ==> numpy의 np.char.문자열함수 기능
```

### 1) 값변경
```python
df = pd.DataFrame({ "a" : [0 ,10, 100],
                    "b" : [2, 20, 200],
                    "c" : [3, 30, 300]},
                    index = list('ABC'))
print(df)
#     a    b    c
A    0    2    3
B   10   20   30
C  100  200  300

new_df = df['a'].replace({0:-1, 10:-2})
print(new_df)

```
### 2) 컬럼명 및 인덱스 변경 
```python
x = df['a'].rename("col1")
print(x)
```

### 3) 참/거짓 여부 
```python
x = df['a'].all()
x = df['a'].any()
x = (df['a']>10).all()     # a컬럼값이 모두 10보다 크냐?
```

### 4) 중복여부
```python

df = pd.DataFrame({"k1":['one']*3 + ['two']*4,
                  "k2":[1,1,2,3,3,4,4] })
print(df)

#    k1  k2
0  one   1
1  one   1
2  one   2
3  two   3
4  two   3
5  two   4
6  two   4 

■ 중복여부 판단
x =df['k1'].duplicated()
print(x)

■ 중복 제거 후 반환
x = df['k1'].drop_duplicates(ignore_index=True)
print(x)


```
### 5) 임의 함수 적용 
```python
df = pd.DataFrame({"국어":[50,60,70,80,90],"수학":[100,100,60,100,80]})
print(df)
#   국어   수학
0  50  100
1  60  60
2  70  100
3  80  100
4  90  80


x = df['국어'].apply(np.sum) # 그룹함수는 적용가능하나 원하는 결과는 안나옴 
x = df['국어'].apply(lambda n: n+1)
print(new_df)
```

### 6) df.isin(집합형)
```python
new_df = df['국어'].is in([60,80])
```

### 7) df['col1'].unique() : unique한 값 리스트 반환
```python
df = pd.DataFrame({ "col1" : [1 ,2, 2, None, 1],
                    "col2" : [2, 3, 2, 2, np.nan],
                    "col3" : [ np.nan, 3, 2, 3, 3],
                    "col4" : [ np.nan, np.nan, np.nan, np.nan, np.nan]},
                    index = [1, 2, 3, 4, 5])
print(df)
#   col1  col2  col3  col4
1   1.0   2.0   NaN   NaN
2   2.0   3.0   3.0   NaN
3   2.0   2.0   2.0   NaN
4   NaN   2.0   3.0   NaN
5   1.0   NaN   3.0   NaN


x = df['col1'].nunique()         # 유니크한 값 종류의 갯수 
x = df['col1'].nunique(dropna=False)
x = df['col1'].unique()          # 유니크 값 반환, sereise 만 사용가능 dataframe불가 

```

### 7) 값의 빈도 수 반환 : df.['col1'].value_counts()
```python
x = df['col2'].value_counts()
x = df['col2'].value_counts(ascending=True) #오름차순
x = df['col2'].value_counts(ascending=True, drop=False)
```

### 8) 범위 포함 여부 판단 : df['col1']between(start, end)
> 있으면 True, 없으면 False

```python
df = pd.DataFrame({"국어":[50,60,70,80,90],"수학":[100,100,60,100,80]})
print(df)
#   국어   수학
0  50  100
1  60  60
2  70  100
3  80  100
4  90  80

x = df['국어'].between(70,100)
print(x)
```

## 5. Series의 문자열(Str) 처리 
```
* 문자열 관련 함수
      가. python
         -문자열. 함수 
         - "hello".upper()
      나. numpy
        - arr = np.array(['aa', 'Bb', 'cc'])
        - np.char.함수명
      다. pandas
        - series.str.함수
```
```python
info={"name":["Hello","Happy","Cat"],
      "age":[18,31, 33],
      "birthday":['1920/09/28','1910/03/26','2020/03/26']}
df = pd.DataFrame(info)
print(df)
#     name  age    birthday
0  Hello   18  1920/09/28
1  Happy   31  1910/03/26
2    Cat   33  2020/03/26

1) series.str.replace(old, new) 함수
df['name1']=df['name'].str.replace("Hello","hello")
print(df)

2) slice
df['name2']= df['name'].str[:]
df['name3']= df['name'].str[::-1] # 역순으로 나옴 
df['name4']= df['name'].str[1:] # 첫글자를 빼고 끝글자까지 나옴 
df['name5']= df['name'].str[0] # 인덱싱, 첫글자만 나옴

3) upper, lower
df['name6'] = df['name'].str.upper()
df['name7'] = df['name'].str.lower()

4) contains(값|값2) : 문자포함 여부 판단
df['name8'] = df['name'].str.contains('a')
df['name8'] = df['name'].str.contains('a'|'e') # 값이 여러개일때는 파이프 연산자 사용
                                               # a "또는" e가 있는지 판단
   ex. name 컬럼에서 a포함된 값출력 
   xxx = df['name']
   print(xxx, type(xxx))
   print(xxx.str.contains('a'))
   print(xxx[xxx.str.contains('a')])

5) startswith(' '), endswith(' ') : 어떤 문자로 시작하거나 끝나는지 판단(boolean 인덱스)
df['name9']=df['name'].str.startswith('H')
print(df)

6) islower
df['name10'] = df['name'].str.islower()
print(df)

7) one-hot 인코딩 변환
pets = pd.Series(['Cat', 'Dog', 'Bird'])
print(pets.str.get_dummies())
```

# 10장. Pandas 이용한 날짜 데이터 처리
```python
    날짜 데이터 처리

   1. str --> datetime로 변환
      pd.to_datetime('날짜')

  2. datetime을 지정된 범위에서 반환
      pd.date_range('날짜', '날짜')

   3.  DatetimeProperties 속성 이용한 날짜 정보 구하기
      df['xxx'].dt.year

   4. datetime --> str로 변환
      df['xxx'].astype(str)
```
## 1. str --> datetime
```python
1) 기본적으로 날짜로 인식가능한 형식
xxx = pd.to_datetime('2023/6/15') #--> 인식가능
xxx = pd.to_datetime('2023-6-15') #--> 인식가능
xxx = pd.to_datetime('2023 6 15') #--> 인식가능
print(xxx)

# 2023-06-15 00:00:00

2) 명시적으로 날짜로 인식해야 하는 형식 
단, xxx = pd.to_datetime('2023:6:15') #-->콜론은 날짜타입으로 인식 불가능
xxx = pd.to_datetime('2023:6:15', format="%Y:%m:%d") 처럼 형식을 설정해주면 인식 가능
xxx = pd.to_datetime('2023년6월15일', format="%Y년%m월%일")
xxx = pd.to_datetime('2023년6월15일 12:24:25', format="%Y년%m월%일 %H:%M:%S")
print(xxx)

+) 연산 가능 : 차이값을 day로 반환
xxx = pd.to_datetime('2023/6/15')
xxx2 = pd.to_datetime('2023/1/15')
print(xxx-xxx2)
```

## 2. pd.date_range('날짜', '날짜') : datetime을 지정된 범위에서 반환
```python
1) start와 end 명시
1-1) 일단위로 반환 (기본 freq="D")
xxx = pd.date_range("2023/1/1", "2023/6/1")
print(xxx)
# DatetimeIndex를 일단위로 반환

2-2) 월단위로 반환
xxx = pd.date_range("2023/1/1", "2023/6/1", freq="M")
xxx = pd.date_range("2023/1/1", "2023/6/1", freq="2M") #2개월 단위로 만들어짐

2-3) 년단위로 반환
xxx = pd.date_range("2023/1/1", "2030/6/1", freq="Y")

2) start + periods
xxx = pd.date_range("2023/1/1", periods=5)
xxx = pd.date_range("2023/1/1", periods=5, freq"M")
xxx = pd.date_range("2023/1/1", periods=5, freq"Y")

+) 활용 : 날짜별 주식가격의 변동 알아보기 
xxx = pd.date_range("2023/6/1", periods=5
df = pd.DataFrame({"시작가격":[500,200,50,240,455],
                   "종가":[1500,1200,150,1240,1455]
                   }, index=xxx)
print(df)
```

## 3. Series -> datatime
```python 
※ 사전 작업 
파이참으로 directory(이름:data)로 만들어서 아래 내용 넣기 
# 파일명 : scientists.csv
'''
Name,Born,Died,Age,Occupation
Rosaline Franklin,1920-07-25,1958-04-16,37,Chemist
William Gosset,1876-06-13,1937-10-16,61,Statistician
Florence Nightingale,1820-05-12,1910-08-13,90,Nurse
Marie Curie,1867-11-07,1934-07-04,66,Chemist
Rachel Carson,1907-05-27,1964-04-14,56,Biologist
John Snow,1813-03-15,1858-06-16,45,Physician
Alan Turing,1912-06-23,1954-06-07,41,Computer Scientist
Johann Gauss,1777-04-30,1855-02-23,77,Mathematician
'''
csv파일 읽어오는 방법
df = pd.read_csv("./directory이름/파일명")
df = pd.read_csv("./data/scientists.csv)

--------------------------------------------------------

born = df['Born']
print(born) # datatype = object(문자열이라는 뜻)
#현재 문자열이라 계산이 안됨 

born = pd.to_datetime(df['Born']) # datatime(날자형식)으로 변경 
died = pd.to_datetime(df['Died']) # datatime(날자형식)으로 변경 
df["생애-일"] = died-born
df["생애=년"] = died.dt.year - born.dt.year
print(df)

```

## 4. Series.dt 년/월/일 따로 출력하기 
> Series는 날짜타입이어야함
```python
xxx = pd.date_range("2023/1/1", periods = 5)
df = pd.DataFrame({"cur_date":xxx})
print(df.info(df['cur_date'].dt))

print("년도:", df['cur_date'].dt.year) #연도만 출력
print("월:", df['cur_date'].dt.month) #월만 출력
print("일:", df['cur_date'].dt.day) #일만 출력

```

## 5. Datetime -> str(문자열)로 변경
```python
print(df['cur_date'], df['cur_date'].astype(str))
```

# 11장. 병합(merge)
```python
    병합(merge)

   1. inner 병합 : 일치하는 행만 반환

      가. 공통 컬럼 이용
          new_df = pd.merge(df, df2,  how=“inner”  on=“공통컬럼명”)
          new_df = pd.merge(df, df2,  how=“inner”  on=[“공통컬럼명”,"공통컬럼명2"]) #==> 복합컬럼이용
          new_df = pd.merge(df, df2,  how=“inner”  on=“공통컬럼명”, indicator=True).query("조건식").drop(columns=[컬럼,.])

      나. 비공통 컬럼 이용
          new_df = pd.merge(df, df2, how='inner', left_on="x1", right_on="y1")
          new_df = pd.merge(df, df2, how='inner', left_on="x1", right_on="y1")
                     .query("조건식")
                     .drop(columns=[컬럼,.])
                     .rename(columns={컬럼:컬럼})

    2. outer 병합 : 일치하는행 + 일치하지 않는 행까지 포함하여 반환 
          가. 공통컬럼 이용
              pd.merge(df, df2,  how=“left|right|outer”,  on=“컬럼명”)
          나. 비공통컬럼 이용
              pd.merge(df, df2,  how“left|right|outer”,  left_on=“컬럼명”,  right_on=“컬럼명” )
                 .query("조건식")
                 .drop(columns=[컬럼,.])
                 .rename(columns={컬럼:컬럼})
```
# 1.inner병합
## 1) 공통 컬럼 이용 
### (1) new_df = pd.merge(df, df2,  how=“inner”  on=“공통컬럼명”)
```python
df1 = pd.DataFrame({"x1":['A','B','C'],
                    "x2":[1, 2, 3]})

df2 = pd.DataFrame({"x1":['A','B','D'],
                    "x3":['T','F','T'],
                    "x4":['T1','F1','T1']})
print(df1)
#
  x1  x2
0  A   1
1  B   2
2  C   3

print(df2)
#   x1 x3  x4
0  A  T  T1
1  B  F  F1
2  D  T  T1

■ 공통컬럼 조회 
new_df = pd.merge(df1, df2, on="x1", how="inner") 혹은 new_df = pd.merge(df1, df2, on=["x1"], how="inner")
print(new_df)
#
  x1  x2 x3  x4
0  A   1  T  T1
1  B   2  F  F1

■ 특정 공통컬럼만 조회 
new_df = pd.merge(df1, df2[['x1','x3']], on="x1", how="inner")
print(new_df)
#
  x1  x2 x3
0  A   1  T
1  B   2  F

■ indicator merge이용해서 병합유형 정보를 알 수 있음
new_df = pd.merge(df1, df2, on="x1", how="inner",inicator=True)

```
### (2) new_df = pd.merge(df, df2,  how=“inner”  on=[“공통컬럼명”,"공통컬럼명2"]) #==> 복합컬럼이용
```
# on=리스트                    
  df = pd.DataFrame(
[
    ['T1', 'G1', 1, 1],
    ['T2', 'G1', 1, 1],
    ['T3', 'G1', 2, 1],
    ['T4', 'G2', 1, 1],
    ['T5', 'G3', 1, 1]
], columns=['TrasactionID', 'GoodsID', 'GoodsIDSeqNo', 'Quantity'])

df2 = pd.DataFrame(
[
    ['G1', 1, 1000],
    ['G1', 2, 1100],
    ['G2', 1, 2000],
    ['G2', 2, 2200]
], columns=['GoodsID', 'GoodsIDSeqNo', 'GoodsPrice'])               
new_df = pd.merge(df1, df2, on=["GoodsID", "GoodsIDSeqNo"], how="inner")
print(new_df)

```
### (3) DataFrame의 속성을 이용하여 query와 drop설정하기 + rename도 설정 가능 
```python
df1 = pd.DataFrame({"x1":['A','B','C'],
                    "x2":[1, 2, 3]})

df2 = pd.DataFrame({"x1":['A','B','D'],
                    "x3":['T','F','T'],
                    "x4":['T1','F1','T1']})
                   
                   
new_df = pd.merge(df1, df2, on="x1", how"inner").query("x1 == 'A'").drop(columns=['x2', 'x4'])
print(new_df)
```

## (4) suffixes : 공통컬럼명을 따로 커스터마이징 할 수 있음
```python
df1 = pd.DataFrame({"x1":['A','B','C'],
                    "x2":[1, 2, 3]})

df2 = pd.DataFrame({"x1":['A','B','D'],
                    "x2":['T','F','T']})
                    
                    
new_df = pd.merge(df1, df2, on="x1", how = "inner", suffixex["_left","_right")
```


## 2) 비공통컬럼 : 공통컬럼이 없는 경우                     
```python
df1 = pd.DataFrame({"x1":['A','B','C'],
                    "x2":[1, 2, 3]})

df2 = pd.DataFrame({"y1":['A','B','D'],
                    "x3":['T','F','T']})     
         
new_df = pd.merge(df1, df2, how="inner", left_on="x1", right_on="y1")         
print(new_df)
```                   
## 3) 컬럼과 index 이용한 병합                   
```python

    컬럼과 index 이용한 병합

     pd.merge(df, df2,  how=“inner”,  left_on=“컬럼명”, right_on=“인덱스” )
     pd.merge(df2, df,  how=“inner”,  left_on="인덱스", right_on=“컬럼명” )

     pd.merge(df, df2,  how=“inner”,  left_on=“컬럼명”, right_index=True )
     pd.merge(df2, df,  how=“inner”,  right_on=“컬럼명”, left_index=True )
```

```python

df1 = pd.DataFrame({"key":['a','b','a','a','b','c'], "value":range(6)})
print(df1)
#
  key  value
0   a      0
1   b      1
2   a      2
3   a      3
4   b      4
5   c      5

df2 = pd.DataFrame({"group_val":[3.5,7]} , index=['a','b'])
print(df2)
#   group_val
a        3.5
b        7.0

new_df = pd.merge(df1, df2, how="inner", left_on="key", right_on=df2.index)
new_df = pd.merge(df1, df2, how="inner", left_on="key", right_index=True)

new_df = pd.merge(df2, df1, how="inner", left_on=df2.index, right_on="key")
new_df = pd.merge(df2, df1, how="inner", left_on=True, right_on="key")
print(new_df)

```
## 4) index와 index 이용한 병합                   
```python
 index 이용한 병합
 
     pd.merge(df, df2,  left_on=“인덱스”, right_on=“인덱스” )

      pd.merge(df, df2,  left_on=“인덱스”, right_index=True )

      pd.merge(df, df2,  right_on=“인덱스”, left_index=True )

      pd.merge(df, df2,  left_index=True, right_index=True )
```
```python
df1 = pd.DataFrame({"key":['a','b','a','a','b','c'],
                     "value":range(6)},
                    index=list('KBSMVC'))
                    
df2 = pd.DataFrame({"g_value":[3.5, 7]},
                    index=['K','S'],
                    )

new_df = pd.merge(df1, df2, how="inner", left_on=df1.index, right_on=df2.index)
new_df = pd.merge(df1, df2, how="inner", left_on=df1.index, right_on=True)

new_df = pd.merge(df2, df1, how="inner", left_index=Ture, right_on=df2.index)
new_df = pd.merge(df2, df1, how="inner", left_index=True, right_on="key")

print(new_df)

```
# 2. outer 병합
## 1) 공통컬럼
```python
df1 = pd.DataFrame({"x1":['A','B','C'],
                    "x2":[1, 2, 3]})

df2 = pd.DataFrame({"x1":['A','B','D'],
                    "x3":['T','F','T'],
                    "x4":['T1','F1','T1']})
print(df1)
#
  x1  x2
0  A   1
1  B   2
2  C   3

print(df2)
#   x1 x3  x4
0  A  T  T1
1  B  F  F1
2  D  T  T1

new_df = pd.merge(df1, df2, how="left", on="x1")
new_df = pd.merge(df1, df2, how="right", on="x1")
new_df = pd.merge(df1, df2, how="outer", on="x1") #양쪽 다 출력

print(new_df)
```
## 2) 비공통컬럼
```python
new_df = pd.merge(df1, df2, how="left", left_on="x1", right_on="y1")
new_df = pd.merge(df1, df2, how="right", left_on="x1", right_on="y1")
new_df = pd.merge(df1, df2, how="outer", left_on="x1", right_on="y1")
print(new_df)

+) 컬럼과 컬럼 => outer join 가능
+) index와 컬럼 => outer join 가능

```

# 12장. 기타함수
## 1. Group by
> df.groupby('그룹으로묶을컬럼명')[선택컬럼].그룹함수

> 예시) emp.groupby(by="deptno")["sal"].sum()
```python
    
department = {"deptno":[10,20,30,40],'dname':['개발','인사','영업','관리'],'loc':['서울','부산','제주','광주']}
employee = {"empno":['A1','A2','A3','A4','A5'],"ename":['홍길동','유관순','안중근','강감찬','이순신'],
            "sal":[1000,1500,2300,3400,4500],"hireday":['2019/01/02','2018/01/02','2017/01/02','2016/01/02','2015/01/02'],
            "deptno":[10,20,10,30,10]}
dept = pd.DataFrame(department)
emp = pd.DataFrame(employee)

예제1) 부서별 sal 합
xxx = emp.groupby(by="deptno")["sal"].sum()
xxx = emp.groupby(by="deptno")["sal"].mean()
xxx = emp.groupby(by="deptno")["sal"].max()
xxx = emp.groupby(by="deptno")["sal"].min()
xxx = emp.groupby(by="deptno")["sal"].count()
print(xxx)
print(pd.DataFrame(xxx))
```

## 2. apply 또는 agg(aggregate) 함수
> df.groupby('그룹으로묶을컬럼명')[선택컬럼].agg(함수명)
```python
def my_mean(v):
    print(">>", v) # deptno별 sal 값 전달됨
    n = len(v)
    sum=0
    for k in v:
        sum+=k
    return sum/n
   pass

xxx = emp.groupby(by="deptno")["sal"].agg(my_mean) #부서번호로 묶은 sal값이 넘어감 
print(xxx)
xxx = emp.groupby(by="deptno")["sal"].mean() # 위 함수와 똑같은 값 나옴 
print(xxx)

+) xxx = emp.groupby(by="deptno")["sal"].agg(np.emp) #numpy함수
   xxx = emp.groupby(by="deptno")["sal"].agg("mena") #python함수

```

## 3. 여러 컬럼에 다양한 함수 적용 
```python
     df.groupby('그룹으로묶을컬럼명').agg({
         컬럼명1:[그룹함수,그룹함수],
         컬럼명2:[그룹함수,그룹함수]
      })
xxx = emp.groupby(by="deptno").agg({
      "sal":["sum","max","min"],
      "deptno":["count"]})
```

# 13장. 파일 읽기
```
1. csv 파일읽기 기본 
df = pd.read_csv(경로)
df = pd.read_csv("./data/scientists.csv")

2. 특정 컬럼을 index로 변경
df = pd.read_csv("./data/scientists.csv", index_col=0)
print(df)

3. 컬럼명 변경 
 - header : 변경할 컬럼
 - name : 변경할 컬럼명
df = pd.read_csv("./data/scientists.csv", header=0,
                 names=['name','born','died','age','occupation'])
print(df)


